# `config/index.js`里`build`的配置


## `build.index`
1. This is where the `index.html` (with injected asset URLs) will be generated.
2. Must be an absolute path on your local file system.


## `build.assetsRoot`
1. 构建出来的文件生成到哪里
2. Must be an absolute path on your local file system.

## `build.assetsSubDirectory`
1. Nest webpack-generated assets under this directory in build.assetsRoot, so that they are not mixed with other files you may have in build.assetsRoot. For example, if build.assetsRoot is `/path/to/dist`, and build.assetsSubDirectory is static, then all Webpack assets will be generated in `path/to/dist/static`.
2. This directory will be cleaned before each build, so it should only contain assets generated by the build.
3. Files inside `/static/` will be copied into this directory as-is during build. This means if you change this prefix, all your absolute URLs referencing files in `/static/` will also need to be changed. See Handling Static Assets for more details.
4. 上面的`build.assetsRoot`是构建出来的`index.html`的所在目录，这里的`build.assetsSubDirectory`是构建出来的 JS、CSS、图片等文件以及从`/static/`搬运过来的文件所在的目录。

## `build.assetsPublicPath`
就是 webpack 的 `output.publicPath`

## `build.productionSourceMap`
Whether to generate source maps for production build.

## `dev.port`
Specify the port for the dev server to listen to.

## `dev.proxyTable`
1. Define proxy rules for the dev server.
2. When integrating this boilerplate with an existing backend, a common need is to access the backend API when using the dev server. To achieve that, we can run the dev server and the API backend side-by-side (or remotely), and let the dev server proxy all API requests to the actual backend.
3. To configure the proxy rules, edit `dev.proxyTable` option.
4. The dev server is using `http-proxy-middleware` for proxying, a simple example:
    ```js
    // config/index.js
    module.exports = {
      // ...
      dev: {
        proxyTable: {
          // proxy all requests starting with /api to jsonplaceholder
          '/api': {
            target: 'http://jsonplaceholder.typicode.com',
            changeOrigin: true,
            pathRewrite: {
              '^/api': ''
            }
          }
        }
      }
    }
    ```
    The above example will proxy the request `/api/posts/1` to `http://jsonplaceholder.typicode.com/posts/1`.
5. In addition to static urls you can also use glob patterns to match URLs, e.g. `/api/**`. See [Context Matching](https://github.com/chimurai/http-proxy-middleware#context-matching) for more details.
6. In addition, you can provide a `filter` option that can be a custom function to determine whether a request should be proxied:
    ```js
    proxyTable: {
      '**': {
        target: 'http://jsonplaceholder.typicode.com',
        filter: function (pathname, req) {
          return pathname.match('^/api') && req.method === 'GET'
        }
      }
    }
    ```
